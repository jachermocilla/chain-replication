1. Data Structure (just for specification)

enum RequestType {
    Query,
    Deposit,
    Withdraw,
    Transfer,
    TransferTo
}
enum RequestOutcome {
    Processed,
    InconsistentWithHistory,
    InsufficientFunds
}
enum UpdateBalanceOutcome {
    Success,
    InsufficientFunds
}
enum CheckRequest {
    Inconsistent,
    Processed,
    NewReq
}
class Request:
    RequestType type;
    String req_id;
    String account_id;
    String bank_id;
    float amount;
    String dest_bank_id;
    String dest_account_id;
    Node client_node;
    int bank_update_seq; # generated at head server, maintained at all servers
    ReqResult req_result;

class ReqResult:
    String req_id;
    RequestOutcome outcome;
    float balance;

class Bank:
    String bank_id;
    Map<String, Account>    account_list;   # key is account_id 

class Account:
    String account_id;
    float balance;
    Map<String, Request> processed_update_list; # <req_id, request>
    # after getting acknowledge from tail, delete request from sent_req_list,
    # put it into processed_update_list, key is req_id of request, no duplicate 

class Node:
    String ip;
    String port;

class Client extends Node:
    HashMap<String, Server> bank_head_list; # key is bank_id
    HashMap<String, Server> bank_tail_list; # key is bank_id

class Server extends Node:
    Bank bank;
    bool is_head;
    bool is_tail;
    bool extending_chain;	
    Server pre_server;
    Server succ_server;
    List<Request> sent_req_list; # need to be searched by req_id/bank_update_seq
    int bank_update_seq;
    # generated by head and maintained by all the servers: when every request
    # reaches the head, it will get a unique seq (unique within this bank)
    HashMap<String, Server> bank_head_list; # key is bank_id

class Master extends Node:
    List<BankServerChain> bank_list;

class BankServerChain:
    Bank bank;
    List<Server> server_chain;
    Server head;
    Server tail;


2. Program entry, threads and event handler
2.1 common class

# each server (master, chain) is a separate process
class ServerProcess extends Process:
    def init(handler):
        self.handler = handler

    def run():
        # each server creates two threads to handle event
        tcp_thread = TCPLoop(self.handler)
        udp_thread = UDPLoop(self.handler)
        tcp_thread.start()
        udp_thread.start()

        if self.to_extend_chain:  # delayed chain server will join chain
            # send_msg_tcp is short for self.send_msg_tcp, same below
            send_msg_tcp(master, JOIN_CHAIN_REQUEST)

        tcp_thread.join()
        udp_thread.join()

    # tcp send is blocking to make sure FIFO request forwarding on chain
    def send_msg_tcp(target, event, *args)
        data = args.serialize(event)  # may use RPC approach
        send_sock = Socket(TCP)
        send_sock.settimeout(config.tcp_timeout)
        # timeout only happens during target server’s failure
        try:
            send_sock.connect(target)
            send_sock.sendall(data)
            send_sock.close()
        except:
            return False

    def send_msg_udp(target, event, *args):
        data = args.serialize(event)
        # assert data fits one package
        send_sock = Socket(UDP)
        send_sock.sendto(target, data)

# TCP listener and event loop
class TCPLoop extends Thread:
    def init(handler):
        self.handle_receive = handler

    def run():
        sock = Socket(TCP)
        sock.bind(config.addr)
        sock.listen()
        while running:
            # blocking tcp handling to ensure FIFO request forwarding on chain
            recv_sock = sock.accept()
            data = recv_sock.complete_recv()
            msg = data.deserialize()
            self.handle_receive(msg)

# UDP listener and event loop
class UDPLoop extends Thread:
    def init(handler):
        self.handle_receive = handler

    def run():
        sock = Socket(UDP)
        sock.bind(config.addr)
        while running:
            data = socket.recvfrom()
            msg = data.deserialize()
            self.handle_receive(msg)

2.2 client thread

# clients are different threads in a single process
class ClientThread extends Thread:
    def run():
        # each client has a receiver thread
        receiver = UDPLoop(handle_receive)
        receiver.start()
        reply_queue = Queue()
        for request in config.requests(filter):
            send_request(request)
            # for simplicity, self keyword may be ignored, same below
        receiver.join()

    def handle_receive(msg):
        case msg.type:
            REQ_RESULT:
                reply_queue.put(msg)
            NEW_HEAD:
                modify_new_head(bank_id, msg.new_head)
            NEW_TAIL:
                modify_new_tail(bank_id, msg.new_tail)

    def send_request(request):
        send_sock = Socket(UDP)
        send_count = 0
        while send_count < config.resend_max:
            # for simplicity, clients know the head and tail of banks initially
            # get dest server address in each retry to use the latest head/tail
            head = get_dest_server(request.bankId, request.type)
            send_sock.sendto(head, request.serialize())
            # block until timeout
            reply = reply_queue.get(timeout = config.udp_timeout)
            # disregard non-relevant reply (req_id not match)
            if reply and reply.req_id == request.req_id:
                return reply
            send_count++
        log_failure()

    def get_dest_server(bank_id, request_type):
        if request_type == RequestType.Query:
            return correct server ∈ self.bank_tail_list
        else:
            return correct server ∈ self.bank_head_list

def main():
    config = load_config(config_file from argv)
    for tid in 1..config.client_threads:
        client = ClientThread(tid)
        client_threads.append(client)
        client.start()
    client_threads.join()


2.3 chain server process

class ChainServer extends ServerProcess:
    def init(config):
        super().init(handler = self.handle_receive)
        report_alive_timer = Timer(config.report_alive_interval, report_alive)
        msg_count = 0
        if config.startup_delay != 0:
            sleep(config.startup_delay)
            self.to_extend_chain = True  # delay is for extending the chain

    def handle_receive(msg):
        case msg.type:
            REQUEST:
                receive_request(msg.request)
            ACKNOWLEDGE:
                receive_acknowledge(msg.bank_update_seq)
            NEW_HEAD:
                modify_new_head(bank_id, msg.new_head)
            NEW_TAIL:
                modify_new_tail(bank_id, msg.new_tail)
            TO_BE_HEAD:
                to_be_head()
            TO_BE_TAIL:
                to_be_tail()
            NEW_SUCC_SERVER:
                succ_server_crashed(new_succ_server)
            NEW_PRE_SERVER:
                pre_server_crashed(new_pre_server)
            NEW_TAIL_COME:
                new_tail_come(new_tail)
            OLD_TAIL_HISTORY:
                new_tail_receive_hist(account_list, bank_update_seq, old_tail)
            OLD_TAIL_SENT_LIST:
                new_tail_receive_sent_list(sent_req_list)

        msg_count += 1
        if (msg_count > config.max_msg_count)    # lifetime expires
            running = False

    def report_alive():
        send_msg_udp(master, SERVER_ALIVE)

def main():
    config = load_config(config_file from argv)
    server_process = ChainServer(config)
    server_process.start()
    server_process.join()

2.4 master server process

class MasterServer extends ServerProcess:
    def init():
        super().init(handler = self.handle_receive)
        check_alive_timer = Timer(config.check_alive_interval, check_alive)

    def handle_receive(msg):
        case msg.type:
            SERVER_ALIVE:
                handle_heartbeat(msg.heartbeat)
            JOIN_CHAIN_REQUEST:
                nofity_new_tail_come(msg.bank.tail, NEW_TAIL_COME,
                                     msg.new_tail)
            NEW_TAIL_READY:
                notify_new_tail(msg.new_tail)

    def notify_new_head(head): # head is a ServerNode which contains bank_id
        notify_all_clients_new_head(head) # assert successful at this stage
        notify_all_tails_new_head(head)

    def notify_new_tail(tail):
        notify_all_clients_new_tail(tail)

    def notify_crash(server):
        if server.is_head && !server.is_tail:       # head crashed
            send_msg_tcp(server.succ_server, TO_BE_HEAD)
            update self.bank_list
            notify_new_head(head)
        else if !server.is_head && server.is_tail:  # tail crashed
            send_msg(server.pre_server, TO_BE_TAIL)
            update self.bank_list
            notify_new_tail(tail)
        else if !server.isHead && !server.isTail:   # internal crashed
            send_msg(server.pre_server, NEW_SUCC_SERVER, server.succ_server)
            send_msg(server.succ_server, NEW_PRE_SERVER, server.pre_server)
            update self.bank_list

    def check_alive():
        for server in server_list:
            if not server.is_crash and
                   time.now() - server.last_report_time > config.crash_timeout:
                server.is_crash = True
                notify_crash(server)

    def handle_heartbeat(heartbeat):
        assert(!heartbeat.server.is_crash)
        heartbeat.server.last_report_time = time.now()

def main():
    config = load_config(config_file from argv)
    master_process = MasterServer()
    master_process.start()
    master_process.join()



# All the following methods are in the ChainServer class
3. Normal Operations For Server (Query, Withdraw, Deposit, Transfer)

def receive_request(request):
    if (request.type == RequestType.Query):
        assert(self.is_tail)
        return handle_query(request)
    
    # processing update request
    assert(request.type != RequestType.Query)

    if (self.is_head and !self.is_tail):		# head server
        self.bank_update_seq ++		# sequence of update request
        request.bank_update_seq = self.bank_update_seq
   return head_handle_update(request)

    if (self.is_head and self.is_tail):		# only one server
        self.bank_update_seq ++		# sequence of update request
        request.bank_update_seq = self.bank_update_seq
        return single_handle_update(request)

    # ignore duplicate update request which is possible when handling failure
    if (self.bank_update_seq >= request.bank_update_seq):
        return
    # assertion based on our FIFO request forwarding assumption
    assert(self.bank_update_seq == request.bank_update_seq - 1)
    self.bank_update_seq = request.bank_update_seq

    if (!self.is_head and self.is_tail):		# tail server
        return tail_handle_update(request)

    assert(!self.is_head && !self.is_tail)		# internal server
    return internal_handle_update(request)


# used for tail or single server
def handle_query(request):		
		    float balance = get_balance(request.account_id)
		    req_result = ReqResult(request.req_id, RequestOutcome.Processed,                                self.balance)
		    send_msg_udp(request.client_node, REQ_RESULT, req_result)
    return req_result

# used in receive_request
def head_handle_update(request):	
	    req_result = get_update_req_result(request)
		    request.req_result = req_result
		    add request to self.sent_req_list
		    send_req_to_succ_server(request)
    return req_result 

# used in receive_request
def internal_handle_update(request):
    req_result = get_update_req_result(request)
    request.req_result = req_result
	    add request to self.sent_req_list
	    send_req_to_succ_server(request)
    return req_result

# used in receive_request
def tail_handle_update_request(request):
    req_result = get_update_req_result(request)	
    request.req_result = req_result
	    if (self.extending_chain):
        add request to self.sent_req_list
    # If check_result is Inconsistent or Processed, the request must have been in     
    # the processed_req_list
    check_result = check_update_request(request)
	    if (check_result == CheckRequest.NewReq):
        update_processed_update_list(request)
    # For Transfer: src bank sends TransferTo request to dest bank
    # InconsistentWithHistory and InsufficientFunds request 
    # are not sent to dest bank
    if (request.type == RequestType.Transfer and 
        req_result.outcome == RequestOutcome.Processed):
        transferto_request = request.copy()
        transferto_request.type = RequestType.TransferTo
        dest_server = self.bank_head_list.get(request.dest_bank_id)
	        send_msg_tcp(dest_server, REQUEST, transferto_request)
    # Dest bank doesn't reply to client
    if (request.type != RequestType.TransferTo):
	        send_msg_udp(request.client_node, REQ_RESULT, req_result)
	    send_ack_to_pre_server(request.bank_update_seq, self.pre_server)
		    return req_result

# used in receive_request
def single_handle_update(request):
    req_result = get_update_req_result(request)		
    request.req_result = req_result
    if (self.extending_chain):
	        add request to self.sent_req_list
    # If check_result is Inconsistent or Processed, the request must have been in     
    # the processed_req_list
    check_result = check_update_request(request)
    if (check_result == CheckRequest.NewReq):
        update_processed_update_list(request)
    # For Transfer: src bank sends TransferTo request to dest bank
    # InconsistentWithHistory and InsufficientFunds request 
    # are not sent to dest bank
    if (request.type == RequestType.Transfer and
        req_result.outcome == RequestOutcome.Processed):
        transferto_request = request.copy()
        transferto_request.type = RequestType.TransferTo
        dest_server = self.bank_head_list.get(request.dest_bank_id)
	        send_msg_tcp(dest_server, REQUEST, transferto_request)
    # Dest bank doesn't reply to client
    if (request.type != RequestType.TransferTo):
	        send_msg_udp(request.client_node, REQ_RESULT, req_result)
	    return req_result 

	# only for head/internal servers
def receive_acknowledge(bank_update_seq):
    request_list = corresponding requests with equal or smaller bank_update_seq in
                  self.sent_req_list
    order the request_list with increasing req.bank_update_seq
    for (req in request_list):
	        account = get_account(request)
	        if req.req_id not exists in account.processed_update_list
	            update_processed_update_list(req)	
	        remove req from self.sent_req_list
        if (!self.is_head):
	            send_ack_to_pre_server(bank_update_seq, self.pre_server)

# used in handle_query
def get_balance(account_id):
    find corresponding account in self.bank.account_list
    return account.balance

# used in all the xxxx_handle_update
def get_update_req_result(request):
    check_result = check_update_request(request)
    if (check_result == CheckRequest.Inconsistent):
	        req_result = ReqResult(request.req_id,                      RequestOutcome.InconsistentWithHistory, self.balance)
    elif (check_result == CheckRequest.Processed):
	        req_result = ReqResult(request.req_id, RequestOutcome.Processed,                      self.balance)
    else:
	        update_result = update_balance(request)
	        if (update_result == UpdateBalanceOutcome.InsufficientFunds):
            req_result = ReqResult(request.req_id,
                         RequestOutcome.InsufficientFunds, self.balance)
		   else:
	            req_result = ReqResult(request.req_id,
                         RequestOutcome.Processed, self.balance)
    return req_result

# used in get_update_req_result
def check_update_request(request):
		    account = get_account(request)
    if (account is None):
		        create account
		        add account into self.bank.account_list
		        return CheckRequest.NewReq
		    if request.req_id exists in self.sent_req_list or        account.processed_update_list:
		        if request content is different:
		            return CheckRequest.Inconsistent
		        else:
		            return CheckRequest.Processed
    else:
	        return CheckRequest.NewReq

# used in check_update_request
def update_balance(request):
    account = get_account(request)
    # If request.type is Transfer, current bank is src bank
    # If request.type is TransferTo, current bank is dest bank
    if (request.type == RequestType.Withdraw or
        request.type == RequestType.Transfer):
        if (account.balance<request.amount):
	            return UpdateBalanceOutcome.InsufficientFunds
		        else:
            account.balance = account.balance - request.amount
            return UpdateBalanceOutcome.Success
	    else:
        account.balance = account.balance + request.amount
		        return UpdateBalanceOutcome.Success

# used in tail_handle_update(request) and single_handle_update(request)
def update_processed_update_list(request):
	    account = get_account(request)
	    insert request into account.processed_updated_list

def get_account(request):
    if (request.type == RequestType.TransferTo):
        return the account with account_id==request.dest_account_id in the 
               self.bank.account_list
    else:
        return the account with account_id==request.account_id in the 
               self.bank.account_list

# If this fails due to the succ_server crashed, just let it go
# In the failure handle module, the requests in the self.sent_req_list will be    # sent again
def send_req_to_succ_server(request): 
    send_msg_tcp(self.succ_server, REQUEST, request)

# If this fails due to the pre_server crashed, just let it go
def send_ack_to_pre_server(bank_update_seq, pre_server):
    send_msg_tcp(pre_server, ACKNOWLEDGEMENT, bank_update_seq)



# All the following methods are in the ChainServer class
4. Failure Handle For Server
4.1 Head Server Failure
# executed on new head server
def to_be_head():
    self.isHead = True
    self.preServer = None

4.2 Tail Server Failure
# executed on the new tail server
def to_be_tail():
    self.succ_server = None
	    for (req in self.sent_req_list):	
        account = get_account(req)
        if req.req_id not exists in account.processed_update_list
            update_processed_update_list(req)
        remove req from self.sent_req_list
        if (!self.isHead):
            send_ack_to_pre_server(req.bank_update_seq, self.pre_server)
        # For Transfer: src bank sends TransferTo request to dest bank
        # InconsistentWithHistory and InsufficientFunds request 
        # are not sent to dest bank
        if (req.type == RequestType.Transfer and
            req.req_result.outcome == RequestOutcome.Processed):
            transferto_request = req.copy()
            transferto_request.type = RequestType.TransferTo
            dest_server = self.bank_head_list.get(req.dest_bank_id)
	            send_msg_tcp(dest_server, REQUEST, transferto_request)
        # Don’t need to reply to client. In client’s perspective, the reply is    
        # lost due to unreliable connection with servers
    self.is_tail = True

4.3 Internal Server Failure
# executed on the pre_server of the crashed server
def succ_server_crashed(new_succ_server):
    succ_server = new_succ_server
	    # some requests might be sent twice
    for (request in self.sent_req_list):
        send_req_to_succ_server(request)

# executed on the succ_server of the crashed server
def pre_server_crashed(new_pre_server):
		pre_server = new_pre_server



# All the following methods are in the ChainServer class
5. Extend Chain
# executed on old tail
def new_tail_come(new_tail):
    self.extending_chain = True
	    process_new_tail_come_thread = Thread(process_new_tail_come_thread)
    process_new_tail_come_thread.start()	# run in background

# used in new_tail_come(new_tail)
def process_new_tail_come_thread():
    send_msg_tcp(new_tail, OLD_TAIL_HISTORY, self.bank.account_list, 
                 self.bank_update_seq, old_tail)
    # new tail will execute new_tail_receive_hist() to receive
    send_msg_tcp(new_tail, OLD_TAIL_SENT_LIST, self.sent_req_list)
    # new tail execute new_tail_receive_sent_list to receive
    remove the requests in self.sent_req_list which have been sent to new_tail
	    self.is_tail = False
    self.extending_chain = False

# executed on new tail
def new_tail_receive_hist(account_list, bank_update_seq, old_tail):
	    self.bank.account_list = account_list
	    self.bank_update_seq = bank_update_seq
	    self.pre_server = old_tail

# executed on new tail
def new_tail_receive_sent_list(sent_req_list):
	    # while handling the sent_req_list, this new tail doesn’t accept newly coming request
	    self.is_tail = True
	    add sent_req_list to self.sent_req_list 
    order self.sent_req_list with increasing req.bank_update_seq
	    for (req in self.sent_req_list):
	        account = get_account(req)
	        if (self.bank_update_seq < req.bank_update_seq)
	            self.bank_update_seq  = req.bank_update_seq
	        req_result = extended_new_tail_deal_update(req)
	        add req_result to req_result_list		
	    send_msg_tcp(master, NEW_TAIL_READY, self)
    return req_result_list

# used in new_tail_receive_sent_list(sent_req_list)
def extended_new_tail_deal_update(request):
    req_result = get_update_req_result(request)
    request.req_result = req_result
    # If check_result is Inconsistent or Processed, the request must have been in     
    # the processed_req_list
    check_result = check_update_request(request)
    if (check_result == CheckRequest.NewReq):
        update_processed_update_list(request)
    # Don’t need to reply client, send transfer request to dest bank, 
    # or send ack to pre_server, because these have been done by the old tail
    return req_result



6. Design of Transfer Operation
6.1 Description
The basic idea of transfer operation is to decrease the account balance (same as withdraw) in srcBank’s chain, then to increase the balance (same as deposit) in destBank’s chain. After the source chain performs the deduction of balance, its tail server forwards the transfer request to destination chain’s head. If the srcBank happens to be the destBank, the tail simply forwards the request to its head again. To distinguish whether the server should perform deduction or addition to the account especially for the srcBank=destBank case, we introduce an internal “TransferTo” request type. The srcBank’s tail will change the request type from “Transfer” to “TransferTo” during forwarding. Note that this “TransferTo” request will first appear on destBank’s head and NOT stored locally on srcBank’s tail. If transfer request results in “InsufficientFunds” or “InconsistentWithHistory”, it is unnecessary to forward to destBank. We think it is sufficient for srcBank’s tail to reply to the client (with the source account’s balance), considering that as in real banks, srcBank should not be aware of dest account’s balance and destBank should not be aware of source account’s balance either.

6.2 Why it works
For liveness:
Assume there are at least one living server in the srcBank’s chain and at least one living server in the destBank’s chain, and consider a correct client that submits a transfer request and never receives any response. 
Consider the chain is stable. In this project, the network connection between two server chains is supposed to be reliable with no possibility of losing requests during communication. Although network connection between server and client is unreliable, clients could continue re-sending requests which get no response. Thus eventually the client will submit its transfer request to the head of srcBank’s chain, and the srcBank’s chain will process the transfer request and then forward the request to destBank’s chain. After the destBank’s chain finish its processing, the transfer operation is complete. 
So: a contradiction.

For safety:
Since the network connection between two chains is supposed to be reliable, if the source chain has processed a transfer request and forwarded it to destination chain, the destination chain will always receive the request and process it with no possibility of losing the request. The transfer requests which come out with the result of “InsufficientFunds” or “InconsistentWithHistory” at the source chain will not be sent to the destination chain, which rules out the possibility that destination chain falsely increase money in account’s balance. As for the special situations of server failure and extending chain, only when the tail is crashed, the new tail which is previous to the old tail in chain, should handle the transfer requests in its sent_req_list by sending them to the destBank’s chain, in order to rule out the possibility that transfer is performed only at the srcBank but not at the destBank. If the reply sent to the client is lost, the client just continue re-sending this request and will get the response finally. Note that requests with same req_id and same request content only update the balance once, so that re-sent request will not influence anything. 


